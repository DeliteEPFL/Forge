diff -r -x target published/OptiML/apps/src/Examples.scala published/OptiML-mod/apps/src/Examples.scala
55c55
<     val v6 = DenseVector(1.,2.,3.,4.,5.) // [1.0,2.0,3.0,4.0,5.0]
---
>     val v6 = DenseVector(1.0,2.0,3.0,4.0,5.0) // [1.0,2.0,3.0,4.0,5.0]
diff -r -x target published/OptiML/apps/src/GDA.scala published/OptiML-mod/apps/src/GDA.scala
39c39
<     val phi = 1./m * y_ones
---
>     val phi = 1.0/m * y_ones
diff -r -x target published/OptiML/apps/src/NaiveBayes.scala published/OptiML-mod/apps/src/NaiveBayes.scala
75c75
<       val pNorm = sumIf(0,ts.numFeatures) { i => ts(j,i) > 0 } { i => (log(phi_y0(i)) + log(1.-phi_y)) * ts(j,i) }
---
>       val pNorm = sumIf(0,ts.numFeatures) { i => ts(j,i) > 0 } { i => (log(phi_y0(i)) + log(1.0-phi_y)) * ts(j,i) }
78c78
<       if (pSpam > pNorm) 1. else 0.
---
>       if (pSpam > pNorm) 1.0 else 0.0
diff -r -x target published/OptiML/apps/src/PDIPSolver/PDIPSolver.scala published/OptiML-mod/apps/src/PDIPSolver/PDIPSolver.scala
324c324
<     DenseMatrix((d/det, -b/det), (-c/det, a/det))
---
>     DenseMatrix(DenseVector(d/det, -b/det), DenseVector(-c/det, a/det))
diff -r -x target published/OptiML/apps/src/SVM.scala published/OptiML-mod/apps/src/SVM.scala
46c46
<         if (((Y(i)*E_i < -1.*tol) && (alphasOld(i) < C)) || ((Y(i)*E_i > tol) && (alphasOld(i) > 0.0))) {        
---
>         if (((Y(i)*E_i < -1.0*tol) && (alphasOld(i) < C)) || ((Y(i)*E_i > tol) && (alphasOld(i) > 0.0))) {        
64c64
<             L = max(0., alphasOld(j) - alphasOld(i))
---
>             L = max(0.0, alphasOld(j) - alphasOld(i))
68c68
<             L = max(0., alphasOld(i) + alphasOld(j) - C)
---
>             L = max(0.0, alphasOld(i) + alphasOld(j) - C)
diff -r -x target published/OptiML/apps/src/TopN.scala published/OptiML-mod/apps/src/TopN.scala
114c114
<     val uniqueRatings = (pairwiseRatings.groupBy(r => (r.profileA, r.profileB), r => r)).toVector // DenseVector[DenseVector[PairwiseRating]]        
---
>     val uniqueRatings = (pairwiseRatings.groupBy(r => DenseVector(r.profileA, r.profileB), r => r)).toVector // DenseVector[DenseVector[PairwiseRating]]        
diff -r -x target published/OptiML/apps/src/kNN.scala published/OptiML-mod/apps/src/kNN.scala
15c15
<     val group = DenseMatrix((1.0, 1.1),(1.0, 1.0),(0.0, 0.0),(0.0, 0.1))
---
>     val group = DenseMatrix(DenseVector(1.0, 1.1),DenseVector(1.0, 1.0),DenseVector(0.0, 0.0),DenseVector(0.0, 0.1))
diff -r -x target published/OptiML/apps/src/minimsmbuilder/DirectSolver.scala published/OptiML-mod/apps/src/minimsmbuilder/DirectSolver.scala
87c87
<     val au2 = -1.*a2
---
>     val au2 = -1.0*a2
150c150
<       s1 = if (s1 >= 0.0) pow(s1,1./3.) else -1.*pow(s1*(-1.),1./3.)  // FIXME AKS: unary_- with vars
---
>       s1 = if (s1 >= 0.0) pow(s1,1.0/3.0) else -1.0*pow(s1*(-1.0),1.0/3.0)  // FIXME AKS: unary_- with vars
153c153
<       s2 = if (s2 >= 0.0) pow(s2,1./3.) else -1.*pow(s2*(-1.),1./3.)
---
>       s2 = if (s2 >= 0.0) pow(s2,1.0/3.0) else -1.0*pow(s2*(-1.0),1.0/3.0)
164c164
<       NewCubicResult(2.0*sq*costh - a2/3.0, -1.0*sq*costh - a2/3.0 - sqrt(3.) * sq * sinth, -1.0*sq*costh - a2/3.0 + sqrt(3.) * sq * sinth, 3)
---
>       NewCubicResult(2.0*sq*costh - a2/3.0, -1.0*sq*costh - a2/3.0 - sqrt(3.0) * sq * sinth, -1.0*sq*costh - a2/3.0 + sqrt(3.0) * sq * sinth, 3)
167,168c167,168
<       val s = if (r >= 0.0) pow(r,1./3.) else -1.0*pow(-1.*r,1./3.)      
<       val t = -1.*s - a2/3.0      
---
>       val s = if (r >= 0.0) pow(r,1.0/3.0) else -1.0*pow(-1.0*r,1.0/3.0)
>       val t = -1.0*s - a2/3.0      
diff -r -x target published/OptiML/compiler/src/optiml/compiler/ops/BasicMathOpsExp.scala published/OptiML-mod/compiler/src/optiml/compiler/ops/BasicMathOpsExp.scala
24a25,26
>   override def fun[A:Manifest,B:Manifest](f: Rep[A] => Rep[B]): Rep[A=>B] = ???
> 
diff -r -x target published/OptiML/compiler/src/optiml/compiler/ops/MiscOpsExp.scala published/OptiML-mod/compiler/src/optiml/compiler/ops/MiscOpsExp.scala
64c64
<     reflectEffect(Misc_Fatal(__arg0)(__pos))
---
>     ??? // XXX reflectEffect(Misc_Fatal(__arg0)(__pos))
diff -r -x target published/OptiML/compiler/src/optiml/compiler/ops/RewriteOpsExp.scala published/OptiML-mod/compiler/src/optiml/compiler/ops/RewriteOpsExp.scala
108c108
<     case Const(x) => Const(implicitly[Numeric[T]].toLong(x))
---
>     // XXX case Const(x) => Const(implicitly[Numeric[T]].toLong(x))
diff -r -x target published/OptiML/compiler/src/optiml/compiler/ops/ValidateOpsImpl.scala published/OptiML-mod/compiler/src/optiml/compiler/ops/ValidateOpsImpl.scala
50c50
<           DenseMatrix((stats(0), stats(1)), (stats(2), stats(3)))
---
>           DenseMatrix(DenseVector(stats(0), stats(1)), DenseVector(stats(2), stats(3)))
Only in published/OptiML-mod/: lib_managed
diff -r -x target published/OptiML/library/src/optiml/library/classes/REPLOverrides.scala published/OptiML-mod/library/src/optiml/library/classes/REPLOverrides.scala
21c21
<   override def repTupleToDense2[A:Manifest,B](t: Tuple2[Rep[A],B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = ???
---
>   // XXX override def repTupleToDense2[A:Manifest,B](t: Tuple2[Rep[A],B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = ???
diff -r -x target published/OptiML/library/src/optiml/library/classes/ValidateWrapperImpl.scala published/OptiML-mod/library/src/optiml/library/classes/ValidateWrapperImpl.scala
52c52
<           DenseMatrix((stats(0), stats(1)), (stats(2), stats(3)))
---
>           DenseMatrix(DenseVector(stats(0), stats(1)), DenseVector(stats(2), stats(3)))
diff -r -x target published/OptiML/project/Build.scala published/OptiML-mod/project/Build.scala
6a7,8
>   //System.setProperty("showSuppressedErrors", "false")
>   System.setProperty("showTimings", "true")
12c14
<     scalaHome := Some(file("/Users/asujeeth/opensource/scala-virtualized-2.11/build/pack/")),
---
>     scalaHome := Some(file(sys.env("SCALA_VIRTUALIZED_HOME"))),
32a35,42
> 
>     //scalacOptions += "-Ydebug",
>     //scalacOptions += "-verbose",
>     //scalacOptions += "-Xlog-implicits",
>     //scalacOptions += "-Ytyper-debug",
> 
>     //scalacOptions += "-Ybreak-cycles",
>     //scalacOptions += "-Ylog:implicits",
39a50,56
>   val virtBuildSettingsDebug = virtBuildSettings ++ Seq(
>     //scalacOptions += "-Ydebug",
>     //scalacOptions += "-verbose",
>     //scalacOptions += "-Xlog-implicits",
>     //scalacOptions += "-Ytyper-debug"
>   )
> 
66c83
<   lazy val OptiMLLib = Project("OptiML-lib", file("library"), settings = virtBuildSettings ++ deps) dependsOn(OptiMLShared)
---
>   lazy val OptiMLLib = Project("OptiML-lib", file("library"), settings = virtBuildSettingsDebug ++ deps) dependsOn(OptiMLShared)
diff -r -x target published/OptiML/shared/src/optiml/shared/ops/DenseVectorOps.scala published/OptiML-mod/shared/src/optiml/shared/ops/DenseVectorOps.scala
19,21c19,22
<   implicit def tupleToDense2[A:Manifest,B](t: Tuple2[A,B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = { DenseVector[A](unit(t._1),__imp0.view(t._2)) }
<   implicit def repTupleToDense2[A:Manifest,B](t: Tuple2[Rep[A],B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = { DenseVector[A](t._1,__imp0.view(t._2)) }
<   implicit def varTupleToDense2[A:Manifest,B](t: Tuple2[Var[A],B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = { DenseVector[A](readVar(t._1),__imp0.view(t._2)) }
---
> // XXX this implicit leads to cycles in BasicMathOps (methods abs, exp, ...). Math.abs is resolved as infix_abs. failure to deduce that Math cannot be converted to DenseVector
> //  implicit def tupleToDense2[A:Manifest,B](t: Tuple2[A,B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = { DenseVector[A](unit(t._1),__imp0.view(t._2)) }
> //  implicit def repTupleToDense2[A:Manifest,B](t: Tuple2[Rep[A],B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = { DenseVector[A](t._1,__imp0.view(t._2)) }
> //  implicit def varTupleToDense2[A:Manifest,B](t: Tuple2[Var[A],B])(implicit __pos: SourceContext,__imp0: Reppable[B,A]): Rep[DenseVector[A]] = { DenseVector[A](readVar(t._1),__imp0.view(t._2)) }
200c201
<     def *(__arg1: Rep[DenseMatrix[Int]])(implicit __pos: SourceContext,__imp1: ROverload31) = { densevector_mul[Float](self,__arg1.toFloat) }
---
>     def *(__arg1: Rep[DenseMatrix[Int]])(implicit __pos: SourceContext,__imp1: ROverload31) = { densevector_mul[Float](self,repToDenseMatrixDenseMatrixOpsCls(__arg1).toFloat) } // XXX: implicit not applied?
227,228c228,229
<     def *(__arg1: Rep[DenseMatrix[Int]])(implicit __pos: SourceContext,__imp1: ROverload34) = { densevector_mul[Double](self,__arg1.toDouble) }
<     def *(__arg1: Rep[DenseMatrix[Float]])(implicit __pos: SourceContext,__imp1: ROverload35) = { densevector_mul[Double](self,__arg1.toDouble) }
---
>     def *(__arg1: Rep[DenseMatrix[Int]])(implicit __pos: SourceContext,__imp1: ROverload34) = { densevector_mul[Double](self,repToDenseMatrixDenseMatrixOpsCls(__arg1).toDouble) }
>     def *(__arg1: Rep[DenseMatrix[Float]])(implicit __pos: SourceContext,__imp1: ROverload35) = { densevector_mul[Double](self,repToDenseMatrixDenseMatrixOpsCls(__arg1).toDouble) }
